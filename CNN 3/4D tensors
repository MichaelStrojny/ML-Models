import torch
import torch.nn as nn
import torch.nn.functional as F

# reduces 3or4-dimensional tensor to 2D tensor (batch, x) suitable for NNs while preserving spatial relationships. How to Use:
# Step 1: create neural network "Model()"
# Step 2: optimize the following Model((CNN(input))

class CNN(nn.Module):
    def __init__(self, input_channels, output_classes, filter_size=3, num_filters=32, pool_size=2):
        super(CNN, self).__init__()

#apply filters
        self.conv = nn.Conv2d(in_channels=input_channels, out_channels=num_filters, kernel_size=filter_size)
        
#pooling layer
        self.pool = nn.MaxPool2d(kernel_size=pool_size)
        
        self.fc = None
        self.num_filters = num_filters
        self.output_classes = output_classes

    def forward(self, x):     #  Convolution -> ReLU Activation -> Pooling -> flatten --> fc layer
        if x.dim() < 3:
            raise ValueError("Tensor must have at least 3 dimensions")
        if x.dim() == 3:
            x = x.unsqueeze(1) 
        
        x = self.pool(F.relu(self.conv(x)))

        if self.fc is None:     #initialized at first input to match dims of flattened convolution output
            self.flattened_size = x.numel() // x.shape[0]  # total elements in tensor / batch size = # of input nodes in linear layer
            self.fc = nn.Sequential(
                nn.Linear(self.flattened_size, 128),     # 128 = random value. Can change if you wish
                nn.ReLU(),
                nn.Linear(128, self.output_classes),
                nn.Softmax(dim=1)
            )

        x = x.view(x.size(0), -1)
        
        x = self.fc(x)
        
        return x
